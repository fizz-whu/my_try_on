<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FaceMesh Glasses</title>
    <style>
        body { margin: 0; overflow: hidden; }
        video { display: none; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <video id="webcam" autoplay playsinline></video>
    <canvas id="output"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let renderer;
        try {
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
        } catch (error) {
            console.error("Error creating WebGL context:", error);
            alert("Unable to initialize WebGL. Your browser may not support it.");
        }

        if (renderer) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            const loader = new THREE.GLTFLoader();
            let glasses;

            loader.load('models/glasses.glb', function (gltf) {
                glasses = gltf.scene;
                scene.add(glasses);
                glasses.visible = false;
                console.log("Glasses model loaded");
            }, undefined, function (error) {
                console.error(error);
            });

            camera.position.z = 2;

            const facemeshModel = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });

            facemeshModel.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            facemeshModel.onResults(onResults);

            async function startWebcam() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    video.srcObject = stream;
                    console.log("Webcam started");
                } catch (error) {
                    console.error("Error starting webcam:", error);
                }
            }

            video.addEventListener('loadeddata', async () => {
                console.log("Video loaded");
                await detectFace();
            });

            async function detectFace() {
                if (facemeshModel) {
                    console.log("Detecting face...");
                    await facemeshModel.send({ image: video });
                    requestAnimationFrame(detectFace);
                }
            }

            function onResults(results) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    console.log("Face landmarks detected");
                    const keypoints = results.multiFaceLandmarks[0];
                    console.log("Keypoints:", keypoints);

                    const nose = keypoints[6];
                    const leftEye = keypoints[33];
                    const rightEye = keypoints[263];
                    console.log("Nose:", nose);
                    console.log("Left Eye:", leftEye);
                    console.log("Right Eye:", rightEye);

                    const faceWidth = distanceBetweenPoints(leftEye, rightEye);
                    console.log("Face Width:", faceWidth);

                    if (glasses) {
                        const nose3D = projectTo3D(nose);
                        const leftEye3D = projectTo3D(leftEye);
                        const rightEye3D = projectTo3D(rightEye);

                        console.log("Nose 3D:", nose3D);
                        console.log("Left Eye 3D:", leftEye3D);
                        console.log("Right Eye 3D:", rightEye3D);

                        const avgX = (leftEye3D.x + rightEye3D.x) / 2;
                        const avgY = (leftEye3D.y + rightEye3D.y) / 2;

                        glasses.position.set(avgX, avgY, nose3D.z - 0.2);
                        glasses.scale.set(faceWidth / 10, faceWidth / 10, faceWidth / 10); // Increased scale
                        glasses.visible = true;
                        console.log("Glasses position:", glasses.position);
                        console.log("Glasses scale:", glasses.scale);

                        const dX = rightEye3D.x - leftEye3D.x;
                        const dY = rightEye3D.y - leftEye3D.y;
                        const rotation = Math.atan2(dY, dX);
                        glasses.rotation.set(0, 0, rotation);
                        console.log("Glasses rotation:", glasses.rotation);
                    }
                } else {
                    if (glasses) {
                        glasses.visible = false;
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            function projectTo3D(point) {
                // Map the normalized coordinates to the correct range
                const x = (point.x * 2) - 1;
                const y = -(point.y * 2) + 1;
                const z = point.z;

                const vector = new THREE.Vector3(x, y, z);
                vector.unproject(camera);

                return vector;
            }

            function distanceBetweenPoints(point1, point2) {
                const dx = point1.x - point2.x;
                const dy = point1.y - point2.y;
                const dz = point1.z - point2.z;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }

            startWebcam();
        }
    </script>
</body>
</html>
